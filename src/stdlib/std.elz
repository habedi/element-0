;;
;; Element 0 Standard Library
;; Version: 0.1.0-alpha.7
;;

(define *elz-stdlib-version* "0.1.0-alpha.7")

;;; ---------------------------------
;;; Logical and Boolean Functions
;;; ---------------------------------

(define (not x)
  (if x #f #t))

(define (!= x y)
  (not (equal? x y)))

;;; ---------------------------------
;;; Type Predicates
;;; ---------------------------------

(define (atom? x)
  (not (pair? x)))

(define (typename x)
  (if (null? x) "nil"
    (if (pair? x) "pair"
      (if (boolean? x) "boolean"
        (if (number? x) "number"
          (if (string? x) "string"
            (if (symbol? x) "symbol"
              (if (procedure? x) "procedure"
                  "unknown"))))))))

;;; ---------------------------------
;;; Numeric Functions
;;; ---------------------------------

(define (abs x)
  (if (< x 0) (- x) x))

(define (square x)
  (* x x))

(define (avg lst)
  (if (null? lst)
      0
      (/ (apply + lst) (length lst))))

(define (fib n)
  (letrec ((iter (lambda (count a b)
                   (if (= count 0)
                       a
                       (iter (- count 1) b (+ a b))))))
    (iter n 0 1)))

;;; ---------------------------------
;;; List Utilities
;;; ---------------------------------

(define (caar x) (car (car x)))
(define (cadr x) (car (cdr x)))
(define (cdar x) (cdr (car x)))
(define (cddr x) (cdr (cdr x)))
(define (caadr x) (car (car (cdr x))))
(define (caddr x) (car (cdr (cdr x))))
(define (cdddr x) (cdr (cdr (cdr x))))

(define (first x) (car x))
(define (rest x) (cdr x))
(define (head x) (car x))
(define (tail x) (cdr x))
(define (nth k lst) (list-ref lst k))

(define (list-ref lst k)
  (letrec ((iter (lambda (l i)
                   (if (= i 0)
                       (car l)
                       (iter (cdr l) (- i 1))))))
    (iter lst k)))

(define (list-tail lst k)
  (letrec ((iter (lambda (l i)
                   (if (= i 0)
                       l
                       (iter (cdr l) (- i 1))))))
    (iter lst k)))

(define (last-element lst)
  (if (null? (cdr lst))
      (car lst)
      (last-element (cdr lst))))

(define (copy-list lst)
  (if (null? lst)
      '()
      (cons (car lst) (copy-list (cdr lst)))))

(define (indexof item lst)
  (letrec ((find (lambda (sublist index)
                  (if (null? sublist)
                      #f
                      (if (equal? (car sublist) item)
                          index
                          (find (cdr sublist) (+ 1 index)))))))
    (find lst 0)))

(define (member obj lst)
  (if (null? lst)
      #f
      (if (equal? obj (car lst))
          lst
          (member obj (cdr lst)))))

(define (assoc obj alist)
  (if (null? alist)
      #f
      (if (equal? obj (caar alist))
          (car alist)
          (assoc obj (cdr alist)))))

(define (take n lst)
  (letrec ((take-iter (lambda (count l acc)
                       (if (or (= count 0) (null? l))
                           (reverse acc)
                           (take-iter (- count 1)
                                      (cdr l)
                                      (cons (car l) acc))))))
    (take-iter n lst '())))

(define (drop n lst)
  (list-tail lst n))

(define (last-pair lst)
  (if (null? (cdr lst))
      lst
      (last-pair (cdr lst))))

;;; ---------------------------------
;;; Iteration
;;; ---------------------------------

(define (for-each proc lst)
  (if (not (null? lst))
      (begin
        (proc (car lst))
        (for-each proc (cdr lst)))))

;;; ---------------------------------
;;; Higher-Order Functions
;;; ---------------------------------

(define (filter pred lst)
  (letrec ((filter-iter (lambda (l acc)
                       (if (null? l)
                           (reverse acc)
                           (if (pred (car l))
                               (filter-iter (cdr l) (cons (car l) acc))
                               (filter-iter (cdr l) acc))))))
    (filter-iter lst '())))

(define (fold-left op initial lst)
  (letrec ((iter (lambda (l acc)
                   (if (null? l)
                       acc
                       (iter (cdr l) (op acc (car l)))))))
    (iter lst initial)))

(define (fold-right op initial lst)
  (if (null? lst)
      initial
      (op (car lst) (fold-right op initial (cdr lst)))))

(define (any? pred lst)
    (if (null? lst)
        #f
        (if (pred (car lst))
            #t
            (any? pred (cdr lst)))))

(define (every? pred lst)
    (if (null? lst)
        #t
        (if (not (pred (car lst)))
            #f
            (every? pred (cdr lst)))))

(define (quicksort lst comparator)
  (if (null? lst)
      '()
      (let ((pivot (car lst))
            (rest (cdr lst)))
        (letrec ((partition (lambda (l less-than greater-than)
                             (if (null? l)
                                 (append (quicksort less-than comparator)
                                         (cons pivot (quicksort greater-than comparator)))
                                 (let ((elem (car l)))
                                   (if (comparator elem pivot)
                                       (partition (cdr l) (cons elem less-than) greater-than)
                                       (partition (cdr l) less-than (cons elem greater-than))))))))
          (partition rest '() '())))))

;;; ---------------------------------
;;; Advanced & Demonstrative
;;; ---------------------------------

(define Y
  (lambda (f)
    ((lambda (g) (g g))
     (lambda (g)
       (f (lambda (a) ((g g) a)))))))
